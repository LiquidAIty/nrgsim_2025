// Get-Weather - get-weather.c
// Written by John Lindgren <john.lindgren@tds.net>, June 17, 2009
// Copyright 2009 The Building Performance Team
// All rights reserved

#include <stdio.h>
#include <stdlib.h>

#include "date.h"
#include "internet.h"
#include "parse.h"
#include "utils.h"
#include "weather.h"
#include "wunderground.h"

enum {INPUT_CITY, INPUT_STATE, INPUT_COUNTRY, INPUT_WMO, INPUT_LATITUDE,
 INPUT_LONGITUDE, INPUT_TIME_ZONE, INPUT_ELEVATION, INPUT_AIRPORT,
 INPUT_START_DATE,  INPUT_END_DATE, INPUT_ITEMS};

static char * input_names[INPUT_ITEMS] = {"City", "State", "Country", "Number "
 "of nearest WMO station", "Latitude (-90 = south to 90 = north)", "Longitude "
 "(-180 = west to 180 = east)", "Time zone (hours from UTC)", "Elevation "
 "(meters)", "Code of nearest airport (e.g. \"GRR\", \"RSW\")", "Starting date "
 "(MM/DD/YYYY)", "Ending date" "(MM/DD/YYYY)"};

char * format_hour (int hour) {
   return alloc_printf ("%d:00 %cM", hour % 12 == 0 ? 12 : hour % 12, hour < 12
    ? 'A' : 'P');
}

int main (int n_args, char * * args) {
  int item, start_day, end_day, hours, day, hour, first, last, hour2;
  struct date start_date, end_date, date, date2;
  char leap_day;
  char input[INPUT_ITEMS][200];
  char * time, * time2;
  double first_value, last_value;
  struct weather * weather, * current;
  
   // read input
   for (item = 0; item < INPUT_ITEMS; item ++) {
      fprintf (stderr, "%s: ", input_names[item]);
      fflush (stderr);
      if (! fgets (input[item], sizeof input[item], stdin)) {
         fprintf (stderr, "Error reading from console.\n");
         exit (1);
      }
      trim (input[item]);
   }
   if (sscanf (input[INPUT_START_DATE], "%d/%d/%d", & start_date.month, &
    start_date.day, & start_date.year) < 3 || ! is_date (start_date)) {
      fprintf (stderr, "Invalid starting date.\n");
      exit (1);
   }

   // figure out end date and whether we have a leap day
   start_day = date_to_day (start_date);
   if (start_date.month < 3)
      leap_day = is_leap_year (start_date.year);
   else
      leap_day = is_leap_year (start_date.year + 1);
   if (leap_day)
      end_day = start_day + 365;
   else
      end_day = start_day + 364;
   end_date = day_to_date (end_day);
   hours = 24 * (1 + end_day - start_day);

   // download weather data
   if (! internet_connect ())
      exit (1);
   weather = safe_realloc (0, sizeof weather[0] * hours);
   for (day = start_day; day <= end_day; day ++)
      get_weather_day (input[INPUT_AIRPORT], day, weather + 24 * (day - start_day));
   internet_disconnect ();

   // interpolate missing values
   for (item = 0; item < ITEMS; item ++) {

      // don't interpolate dewpoint
      if (item == DEWPOINT)
         continue;
   
      hour = 0;
      while (1) {
         
         // find a range of missing
         while (hour < hours && weather[hour].valid[item])
            hour ++;
         if (hour == hours)
            break;
         first = hour;
         while (hour < hours && ! weather[hour].valid[item])
            hour ++;
         last = hour - 1;
         
         // print a warning
         date = day_to_date (start_day + first / 24);
         date2 = day_to_date (start_day + last / 24);
         time = format_hour (first % 24);
         time2 = format_hour (last % 24);
         fprintf (stderr, "Filling %s from %d/%d %s to %d/%d %s.\n",
          names[item], date.month, date.day, time, date2.month, date2.day,
          time2);
         free (time);
         free (time2);
         
         // get endpoints
         first_value = 0;
         if (first > 0)
            first_value = weather[first - 1].values[item];
         last_value = first_value;
         if (last < hours - 1)
            last_value = weather[last + 1].values[item];
         if (first == 0)
            first_value = last_value;
         
         // interpolate
         for (hour2 = first; hour2 <= last; hour2 ++) {
            weather[hour2].valid[item] = 1;
            weather[hour2].values[item] = first_value + (last_value -
             first_value) * (1 + hour2 - first) / (2 + last - first);
         }
      }
   }

   // print .epw header
   printf ("LOCATION,%s,%s,%s,,%s,%s,%s,%s,%s\n", input[INPUT_CITY],
    input[INPUT_STATE], input[INPUT_COUNTRY], input[INPUT_WMO],
    input[INPUT_LATITUDE], input[INPUT_LONGITUDE], input[INPUT_TIME_ZONE],
    input[INPUT_ELEVATION]);
   printf ("DESIGN CONDITIONS,0\n");
   printf ("TYPICAL/EXTREME PERIODS,0\n");
   printf ("GROUND TEMPERATURES,0\n");
   printf ("HOLIDAYS/DAYLIGHT SAVING,%s,,,0\n", leap_day ? "Yes" : "No");
   printf ("COMMENTS 1,Generated by Get-Weather based on data retrieved from "
    "Weather Underground <http://wunderground.com>.\n");
   printf ("COMMENTS 2,Copyright 2009 The Building Performance Team. All rights"
    " reserved.\n");
   printf ("DATA PERIODS,1,1,Period 1,Sunday,%d/%d,%d/%d\n", start_date.month,
    start_date.day, end_date.month, end_date.day);
   
   // print .epw weather data
   current = weather;
   for (day = start_day; day <= end_day; day ++) {
      date = day_to_date (day);
      for (hour = 0; hour < 24; hour ++) {
         printf ("%d,%d,%d,%d,1,", date.year, date.month, date.day, 1 + hour);
         printf ("B8%sB8?9", current->valid[DEWPOINT] ? "B8" : "?9");
         printf ("?9?9?9?9?9?9?9?9" "B8B8B8B8" "?9?9?9?9?9?9,");
         if (current->valid[DEWPOINT])
            printf ("%.2lf,%.2lf,%.2lf,999999,", current->values[TEMPERATURE],
             current->values[DEWPOINT], current->values[HUMIDITY] * 100);
         else
            printf ("%.2lf,99.9,%.2lf,999999,", current->values[TEMPERATURE],
             current->values[HUMIDITY] * 100);
         printf ("9999,9999,9999,9999,9999,9999,999999,999999,999999,9999,");
         printf ("%.0lf,%.2lf,%.2lf,%.2lf,", current->values[WIND_DIR],
          current->values[WIND_SPEED], current->values[COVER] * 10,
          current->values[COVER] * 10);
         printf ("9999,999999,9,999999999,999,.999,999,99,999,999,99\n");
         current ++;
      }
   }

   free (weather);
}